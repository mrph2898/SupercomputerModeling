\documentclass[12pt, fleqn]{article}

\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage{amssymb,amsmath,mathrsfs,amsthm}
\usepackage[russian]{babel}
\usepackage{graphicx}
\graphicspath{ {../imgs/} }
\usepackage[footnotesize]{caption}
\usepackage{indentfirst}
\usepackage{amsthm}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage[labelsep=space, singlelinecheck=on]{subcaption}

\usepackage{algorithm, setspace}
\usepackage{algpseudocode}
\usepackage[matrix,frame,arrow]{xy}
\usepackage[braket, qm]{qcircuit}
\usepackage[hyphens]{url}
\usepackage[colorlinks=true]{hyperref}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{color}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{multirow}
\usepackage{tabularx}
    \newcolumntype{L}{>{\raggedright\arraybackslash}X}

\textheight=24cm
\textwidth=16cm
\oddsidemargin=5mm
\evensidemargin=-5mm
\marginparwidth=36pt
\topmargin=-1.5cm
\footnotesep=3ex
%\flushbottom
\raggedbottom
\tolerance 3000
\clubpenalty=10000
\widowpenalty=10000
\renewcommand{\baselinestretch}{1.1}
\renewcommand{\baselinestretch}{1.5} 

\addto\captionsrussian{\def\refname{Источники}}
\theoremstyle{definition}
\newtheorem{define}{Определение}
\newtheorem{theorem}{Теорема}
\newtheorem{lemma}[theorem]{Лемма}
\newtheorem{assumption}{Утверждение}

\def\vec#1{\mathchoice{\mbox{\boldmath$\displaystyle#1$}}
{\mbox{\boldmath$\textstyle#1$}} {\mbox{\boldmath$\scriptstyle#1$}} {\mbox{\boldmath$\scriptscriptstyle#1$}}}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{gray}{rgb}{0.4,0.4,0.4}
\definecolor{darkblue}{rgb}{0.0,0.0,0.6}
\definecolor{lightblue}{rgb}{0.0,0.0,0.9}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}
\definecolor{darkred}{rgb}{0.6,0.0,0.0}
\definecolor{purple}{rgb}{0.58,0,0.82}


\lstset{
  basicstyle=\ttfamily\footnotesize,
  columns=fullflexible,
  showstringspaces=false,
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=1,
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=none,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title  
  commentstyle=\color{gray}\upshape
}


\lstdefinelanguage{XML}
{
  morestring=[s][\color{mauve}]{"}{"},
  morestring=[s][\color{black}]{>}{<},
  morecomment=[s]{<?}{?>},
  morecomment=[s][\color{dkgreen}]{<!--}{-->},
  stringstyle=\color{black},
  identifierstyle=\color{lightblue},
  keywordstyle=\color{red},
  caption={\protect\filename@parse{\lstname}\protect\filename@base\text{.}\protect\filename@ext},
  morekeywords={xmlns,xsi,noNamespaceSchemaLocation,type,id,x,y,source,target,version,tool,transRef,roleRef,objective,eventually}% list your attributes here
}

\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
%   frame=L,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\linespread{0.8}\small\ttfamily,
  keywordstyle=\bfseries\color{dkgreen},
  commentstyle=\itshape\color{purple},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
  caption={\protect\filename@parse{\lstname}\protect\filename@base\text{.}\protect\filename@ext}
}


\newenvironment{packed_enum}{
\begin{enumerate}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{enumerate}}

\begin{document}
\hypersetup{pageanchor=false}
% \pagenumbering{Alph} % for correct numbering of document
\begin{titlepage}
\begin{center}
    \includegraphics[width=58mm]{msu.eps}
    
    Московский государственный университет имени М.В.Ломоносова\\
    Факультет вычислительной математики и кибернетики\\
    Кафедра математических методов прогнозирования\\[25mm]

    \textsf{
        \Large\bfseries 
        Задание по курсу <<Суперкомпьютерное моделирование и технологии>>
        \\[5mm] 
        Решение краевой задачи для уравнения Пуассона методом конечных разностей с использованием технологий MPI+OpenMP+CUDA.
    }\\[12mm]
    
    \begin{flushright}
        \parbox{0.5\textwidth}{
        \begin{flushright}
            \textbf{Выполнил:}\\
            студент 617 группы \\
            Г.В. Кормаков
        \end{flushright}
        }
    \end{flushright}

    \vspace{\fill}
    Москва, 2021
\end{center}

\end{titlepage}
\hypersetup{pageanchor=true}
% \pagenumbering{arabic} % for correct numbering of document
\tableofcontents
\newpage
\section{Постановка задачи}
В прямоугольнике $\Pi=\left\{(x, y): A_{1} \leqslant x \leqslant A_{2}, B_{1} \leqslant y \leqslant B_{2}\right\}$, граница $\Gamma$ которого состоит из отрезков
\abovedisplayskip=1pt
\belowdisplayskip=2pt
\noindent
$$
\begin{array}{ll}
\gamma_{R}=\left\{\left(A_{2}, y\right), B_{1} \leqslant y \leqslant B_{2}\right\}, & \gamma_{L}=\left\{\left(A_{1}, y\right), B_{1} \leqslant y \leqslant B_{2}\right\} \\
\gamma_{T}=\left\{\left(x, B_{2}\right), A_{1} \leqslant x \leqslant A_{2}\right\}, & \gamma_{B}=\left\{\left(x, B_{1}\right), A_{1} \leqslant x \leqslant A_{2}\right\}
\end{array}
$$
рассматривается дифференциальное уравнение Пуассона с потенциалом
\abovedisplayskip=1pt
\belowdisplayskip=2pt
\noindent
\begin{gather}
-\Delta u+q(x, y) u=F(x, y) \label{eq:poisson}
\end{gather}
в котором оператор Лапласа
\abovedisplayskip=1pt
\belowdisplayskip=2pt
\noindent
\begin{gather}
\Delta u=\frac{\partial}{\partial x}\left(k(x, y) \frac{\partial u}{\partial x}\right)+\frac{\partial}{\partial y}\left(k(x, y) \frac{\partial u}{\partial y}\right) \label{eq:laplace}
\end{gather}

Для выделения единственного решения уравнение дополняется граничными условиями. На каждом отрезке границы прямоугольника $\Pi$ задается условие одним из двух способов - условиями Дирихле (1-ого типа) или условиями второго (Неймана) и третьего типа. 

\textbf{Для выданного варианта 8 задания} краевые условия задаются следующими условиями: третьего типа на правой и левой границе и второго на верхней и нижней на сетке (см. раздел \ref{sec:numeric}). Общая формула условий третьего типа выглядит следующим образом:
\abovedisplayskip=1pt
\belowdisplayskip=2pt
\noindent
\begin{gather}
 \left(k \frac{\partial u}{\partial \vec{n}}\right)(x, y)+\alpha u(x, y)=\psi(x, y),
 \label{eq:neumann}
\end{gather}
где $\vec{n}$ - единичная внешняя нормаль к границе прямоугольника.

Краевое условие второго типа (условие Неймана) содержится в краевом условии третьего типа (случай $\alpha=0$ в \ref{eq:neumann}).

Функции $F(x, y), \varphi(x, y), \psi(x, y)$, коэффициент $k(x, y)$, потенциал $q(x, y)$ и параметр $\alpha \geqslant 0$ считаются известными, функцию $u(x, y)$, удовлетворяющую уравнению \ref{eq:poisson} и граничным условиям, определенным вариантом задания 8, требуется найти.

Важно отметить, что нормаль $\vec{n}$ не определена в угловых точках прямоугольника. Краевое условие третьего типа будет рассматриваться лишь в тех точках границы, где нормаль существует.
\section{Численный метод решения}\label{sec:numeric}
\subsection{Общая схема метода конечных разностей}
В качестве метода решения задачи Пуассона \ref{eq:poisson} с потенциалом предлагается использовать метод конечных разностей.

Для этого область $\Pi$ дискретизуем сеткой $\overline{\omega}_{h}=\overline{\omega}_{1} \times \overline{\omega}_{2}$, где $\overline{\omega}_{1}$ -- разбиение сетки по оси $Ox$ с шагом $h_{1}=\frac{A_{2}-A_{1}}{M}$ и $\overline{\omega}_{2}$ -- разбиение сетки по оси $Oy$ с шагом $ h_{2}=\frac{B_{2}-B_{1}}{N}$ :
\abovedisplayskip=1pt
\belowdisplayskip=2pt
\noindent
$$
\overline{\omega}_{1}=\left\{x_{i}=A_{1}+i h_{1}, i=\overline{0, M}\right\}, \overline{\omega}_{2}=\left\{y_{j}=B_{1}+j h_{2}, j=\overline{0, N}\right\}
$$
Также примем обозначение $\omega_{h}$ для внутренних узлов сетки $\overline{\omega}_{h}$

Рассматривается линейное пространство $H$ функций, заданных на сетке $\overline{\omega}_{h}$. Обозначим через $w_{ij}$ значение сеточной функции $w \in H$ в узле сетки $\left(x_{i}, y_{j}\right) \in \overline{\omega}_{h}$. Будем считать, что в пространстве $H$ задано скалярное произведение и евклидова норма
\abovedisplayskip=1pt
\belowdisplayskip=2pt
\noindent
$$
[u, v]=\sum_{i=0}^{M} h_{1} \sum_{j=0}^{N} h_{2} \rho_{i j} u_{i j} v_{i j}, \quad\|u\|_{E}=\sqrt{[u, u]},
$$

где $\rho_{i j}$ -- весовая функция $\rho_{i j}=\rho^{(1)}\left(x_{i}\right) \rho^{(2)}\left(y_{j}\right)$ с
\abovedisplayskip=1pt
\belowdisplayskip=2pt
\noindent
$$
\rho^{(1)}\left(x_{i}\right)=\left[\begin{array}{rl}
1, & 1 \leqslant i \leqslant M-1 \\
1 / 2, & i=0, i=M
\end{array} \quad \rho^{(2)}\left(y_{j}\right)=\left[\begin{array}{rl}
1, & 1 \leqslant j \leqslant N-1 \\
1 / 2, & j=0, j=N
\end{array}\right.\right.
$$

В методе конечных разностей дифференциальная задача математической физики заменяется конечно-разностной операторной задачей вида
\abovedisplayskip=1pt
\belowdisplayskip=2pt
\noindent
\begin{gather}
A w=B
\label{eq:diff_scheme}
\end{gather}
где $A: H \rightarrow H$ -- оператор, действующий в пространстве сеточных функций, $B \in H-$ известная правая часть. Задача \ref{eq:diff_scheme} называется разностной схемой. Решение этой задачи считается численным решением исходной дифференциальной задачи.
\subsection{Конкретный вид разностной схемы для варианта 8}
Уравнение \ref{eq:poisson} приближается для всех внутренних точек $\omega_h$ сетки разностной схемой следующего вида:
\abovedisplayskip=1pt
\belowdisplayskip=2pt
\noindent
\begin{gather*}
 -\Delta_{h} w_{i j}+q_{i j} w_{i j}=F_{i j}, \quad i=\overline{1, M-1}, j=\overline{1, N-1},
\end{gather*}
в котором  $F_{i j}=F\left(x_{i}, y_{j}\right), q_{i j}=q\left(x_{i}, y_{j}\right)$ и  разностный оператор Лапласа
\begin{gather*}
\Delta_{h} w_{i j}= \frac{1}{h_{1}}\left(k\left(x_{i}+0.5 h_{1}, y_{j}\right) \frac{w_{(i+1) j}-w_{i j}}{h_{1}}-k\left(x_{i}-0.5 h_{1}, y_{j}\right) \frac{w_{i j}-w_{(i-1) j}}{h_{1}}\right)+\\
+\frac{1}{h_{2}}\left(k\left(x_{i}, y_{j}+0.5 h_{2}\right) \frac{w_{i (j+1)}-w_{i j}}{h_{2}}-k\left(x_{i}, y_{j}-0.5 h_{2}\right) \frac{w_{i j}-w_{i (j-1)}}{h_{2}}\right)
\end{gather*}
В разностном операторе Лапласа введём обозначения для правых и левых разностных производных по координатам:
\begin{gather*}
w_{x, i j} \equiv \frac{w_{(i+1) j} - w_{i j}}{h_{1}}, \quad w_{\overline{x}, i j} \equiv w_{x, (i-1) j}=\frac{w_{i j}-w_{(i-1) j}}{h_{1}}\\
w_{y, i j} \equiv \frac{w_{i (j+1)}-w_{i j}}{h_{2}}, \quad w_{\overline{y}, i j} \equiv w_{y, i (j-1)} \equiv \frac{w_{i j}-w_{i (j-1)}}{h_{2}}
\end{gather*}
и зададим сеточные коэффициенты
\begin{gather*}
a_{i j} \equiv k\left(x_{i}-0.5 h_{1}, y_{j}\right), \quad b_{i j}\equiv k\left(x_{i}, y_{j}-0.5 h_{2}\right).
\end{gather*}
Тогда разностный оператор Лапласа равен
\begin{gather}\nonumber 
\Delta_{h} w_{i j}= \frac{1}{h_{1}}\left(k\left(x_{i}+0.5 h_{1}, y_{j}\right) w_{x, ij} - k\left(x_{i}-0.5 h_{1}, y_{j}\right) w_{x, (i-1)j }\right)+ \\ \nonumber 
+\frac{1}{h_{2}}\left(k\left(x_{i}, y_{j}+0.5 h_{2}\right) w_{y, i j} - k\left(x_{i}, y_{j}-0.5 h_{2}\right) w_{y, i (j-1)}\right) = \\
= \frac{a_{(i+1) j} w_{x, ij} - a_{ij} w_{x, (i-1)j }}{h_{1}} + \frac{b_{i (j+1)} w_{y, i j} - b_{ij} w_{y, i (j-1)}}{h_{2}} = \nonumber\\ 
= \frac{a_{(i+1) j} w_{\overline{x}, (i+1)j} - a_{ij} w_{\overline{x}, ij }}{h_{1}} + \frac{b_{i (j+1)} w_{\overline{y}, i (j+1)} - b_{ij} w_{\overline{y}, i j}}{h_{2}} \equiv \left(a w_{\overline{x}}\right)_{x, i j}+\left(b w_{\overline{y}}\right)_{y, i j} \label{eq:laplace_diff}
\end{gather}
Итого, получаем $(M-1)\cdot(N-1)$ уравнений во внутренних точках:
\begin{gather}
 -\Delta_{h} w_{i j}+q_{i j} w_{i j} =F_{i j}, \quad i=\overline{1, M-1}, j=\overline{1, N-1} 
 \label{eq:main_int}
\end{gather}
Рассмотрим конкретные граничные условия, заданные в варианте 8 (см. таблицу \ref{tb:variant}).

Для правой (схема \ref{eq:right})  и левой (схема \ref{eq:left}) границы ($\gamma_R, \gamma_L$ соответственно) задаются условия третьего типа. Разностный вариант (с учётом членов для соответствия порядка погрешности аппроксимации с основным уравнением \ref{eq:laplace_diff}) для них выглядит следующим образом:
\begin{gather}
 \frac{2}{h_{1}}\left(a w_{\overline{x}}\right)_{M j} + \left(q_{M j}+\frac{2 \alpha_{R}}{h_{1}}\right) w_{M j}-\left(b w_{\overline{y}}\right)_{y, M j}=F_{M j}+\frac{2}{h_{1}} \psi^{(R)}_{M j}, \quad j=\overline{1, N-1} \label{eq:right}\\
-\frac{2}{h_{1}}\left(a w_{\overline{x}}\right)_{1 j}+\left(q_{0 j}+\frac{2 \alpha_{L}}{h_{1}}\right) w_{0 j}-\left(b w_{\overline{y}}\right)_{y, 0 j}=F_{0 j}+\frac{2}{h_{1}} \psi^{(L)}_{0 j}, \quad j=\overline{1, N-1}\label{eq:left}
\end{gather}
Для верхней (схема \ref{eq:top})  и нижней (схема \ref{eq:bottom}) границы ($\gamma_T, \gamma_B$ соответственно) задаются условия второго типа (Неймана).
\begin{gather}
\frac{2}{h_{2}}\left(b w_{\overline{y}}\right)_{i N} + q_{i N} w_{i N}-\left(a w_{\overline{x}}\right)_{x, i N}=F_{i N}+\frac{2}{h_{2}} \psi^{(T)}_{i N},\quad  i=\overline{1, M-1}  \label{eq:top}\\
-\frac{2}{h_{2}}\left(b w_{\overline{y}}\right)_{i 1}+q_{i 0} w_{i 0}-\left(a w_{\overline{x}}\right)_{x, i 0}=F_{i 0}+\frac{2}{h_{2}} \psi^{(B)}_{i 0},\quad  i=\overline{1, M-1} \label{eq:bottom}
\end{gather}

Также в угловых точках не определена нормаль, поэтому необходимо их учесть отдельными уравнениями.

Для точки $P\left(A_{1}, B_{1}\right)$ прямоугольника $\Pi$
\begin{gather}
-\frac{2}{h_{1}}\left(a w_{\overline{x}}\right)_{10} - \frac{2}{h_{2}} \left(b w_{\overline{y}}\right)_{01}+\left(q_{00}+ \frac{2\alpha_{L}}{h_{1}}\right) w_{00}= F_{00}+\left(\frac{2}{h_{1}} + \frac{2}{h_{2}}\right) \psi_{00}
\label{eq:a1b1}
\end{gather}
\vspace{10pt}
Для точки $P\left(A_{2}, B_{1}\right)$ прямоугольника $\Pi$
\begin{gather}
\frac{2}{h_{1}}\left(a w_{\overline{x}}\right)_{M 0}-\frac{2}{h_{2}}\left(b w_{\overline{y}}\right)_{M 1}+\left(q_{M 0}+\frac{2\alpha_{R}}{h_{1}}\right) w_{M 0} = F_{M 0}+\left(\frac{2}{h_{1}}+\frac{2}{h_{2}}\right) \psi_{M 0}
\label{eq:a2b1}
\end{gather}
\vspace{10pt}
Для точки $P\left(A_{2}, B_{2}\right)$ прямоугольника $\Pi$
\begin{gather}
\frac{2}{h_{1}}\left(a w_{\overline{x}}\right)_{M N}+\frac{2}{h_{2}}\left(b w_{\overline{y}}\right)_{M N}+\left(q_{M N}+\frac{2\alpha_{R}}{h_{1}}\right) w_{M N}= F_{M N}+\left(\frac{2}{h_{1}}+\frac{2}{h_{2}}\right) \psi_{M N}
\label{eq:a2b2}
\end{gather}
\vspace{10pt}
Для точки $P\left(A_{1}, B_{2}\right)$ прямоугольника $\Pi$
\begin{gather}
-\frac{2}{h_{1}}\left(a w_{\overline{x}}\right)_{1 N}+\frac{2}{h_{2}}\left(b w_{\overline{y}}\right)_{0 N}+\left(q_{0 N}+\frac{2\alpha_{L}}{h_{1}}\right) w_{0 N}= F_{0 N}+\left(\frac{2}{h_{1}}+\frac{2}{h_{2}}\right) \psi_{0 N}
\label{eq:a1b2}
\end{gather}
Уточним, что обозначили за $\psi^{(T)}, \psi^{(B)}$ фунции краевых условий второго типа (для данного варианта), а  за $\psi^{(R)}, \psi^{(L)}$ -- функции краевых условий третьего типа. В угловых точках вектор нормали не определён, поэтому краевые условия равны значению функции $u(x, y)$.
\begin{table}[!ht]
\begin{tabular}{|c|cccc|c|c|c|}
\hline Вариант & \multicolumn{4}{c|}{ Граничные условия } & Решение & Коэфф. & Потенциал \\
задания & $\gamma_{R}$ & $\gamma_{L}$ & $\gamma_{T}$ & $\gamma_{B}$ & $\mathrm{u}(\mathrm{x}, \mathrm{y})$ & $k(x, y)$ & $q(x, y)$ \\
\hline 8 & 3 тип & 3 тип & 2 тип & 2 тип & $u_{2}(x, y)$ & $k_{3}(x, y)$ & $q_{2}(x, y)$\\
\hline
\end{tabular}
\caption{Условия задания}
\label{tb:variant}
\end{table}

Запишем \textbf{финальную систему}, убедившись, что она определена.
\begin{align*}
  -\left(a w_{\overline{x}}\right)_{x, i j}-\left(b w_{\overline{y}}\right)_{y, i j}+q_{i j} w_{i j} &=F_{i j}, i=\overline{1, M-1}, j=\overline{1, N-1}\\
 \frac{2}{h_{1}}\left(a w_{\overline{x}}\right)_{M j} + \left(q_{M j}+\frac{2 }{h_{1}}\right) w_{M j}-\left(b w_{\overline{y}}\right)_{y, M j}&=F_{M j}+\frac{2}{h_{1}} \psi^{(R)}_{M j}, \; j=\overline{1, N-1} \\
-\frac{2}{h_{1}}\left(a w_{\overline{x}}\right)_{1 j}+\left(q_{0 j}+\frac{2}{h_{1}}\right) w_{0 j}-\left(b w_{\overline{y}}\right)_{y, 0 j}&=F_{0 j}+\frac{2}{h_{1}} \psi^{(L)}_{0 j}, \; j=\overline{1, N-1}\\
\frac{2}{h_{2}}\left(b w_{\overline{y}}\right)_{i N} + q_{i N} w_{i N}-\left(a w_{\overline{x}}\right)_{x, i N}&=F_{i N}+\frac{2}{h_{2}} \psi^{(T)}_{i N},\;  i=\overline{1, M-1}  \\
-\frac{2}{h_{2}}\left(b w_{\overline{y}}\right)_{i 1}+q_{i 0} w_{i 0}-\left(a w_{\overline{x}}\right)_{x, i 0}&=F_{i 0}+\frac{2}{h_{2}} \psi^{(B)}_{i 0},\;  i=\overline{1, M-1} \\
-\frac{2}{h_{1}}\left(a w_{\overline{x}}\right)_{10} - \frac{2}{h_{2}} \left(b w_{\overline{y}}\right)_{01}+\left(q_{00}+ \frac{2}{h_{1}}\right) w_{00}&= F_{00}+\left(\frac{2}{h_{1}} + \frac{2}{h_{2}}\right) \frac{\psi^{(L)}_{00} + \psi^{(B)}_{00}}{2}\\
\frac{2}{h_{1}}\left(a w_{\overline{x}}\right)_{M 0}-\frac{2}{h_{2}}\left(b w_{\overline{y}}\right)_{M 1}+\left(q_{M 0}+\frac{2}{h_{1}}\right) w_{M 0} &= F_{M 0}+\left(\frac{2}{h_{1}}+\frac{2}{h_{2}}\right) \frac{\psi^{(R)}_{M 0} + \psi^{(B)}_{M 0}}{2}\\
\frac{2}{h_{1}}\left(a w_{\overline{x}}\right)_{M N}+\frac{2}{h_{2}}\left(b w_{\overline{y}}\right)_{M N}+\left(q_{M N}+\frac{2}{h_{1}}\right) w_{M N}&= F_{M N}+\left(\frac{2}{h_{1}}+\frac{2}{h_{2}}\right) \frac{\psi^{(R)}_{M N} + \psi^{(T)}_{M N}}{2}\\
-\frac{2}{h_{1}}\left(a w_{\overline{x}}\right)_{1 N}+\frac{2}{h_{2}}\left(b w_{\overline{y}}\right)_{0 N}+\left(q_{0 N}+\frac{2}{h_{1}}\right) w_{0 N}&= F_{0 N}+\left(\frac{2}{h_{1}}+\frac{2}{h_{2}}\right) \frac{\psi^{(L)}_{0 N} + \psi^{(T)}_{0 N}}{2}
\end{align*}

Получили $(N-1)(M-1) + 2(M-1) + 2(N-1) + 4 = MN - M - N + 1 + 2M + 2N - 4 + 4 = MN + N + M + 1$ уравнений. Число неизвестных $w_{ij}$ равно $(M+1)(N+1) = MN + N + M + 1$. И система гарантирует единственность решения для данной разностной схемы.

Таким образом, матрица оператора $A$ определяется коэффициентами перед неизвестными в левой части, а матрицы $B$ -- в правой.

\subsection{Метод решения СЛАУ}
Приближенное решение системы уравнений для сформулированных выше краевых задач может быть получено итерационным методом наименьших невязок. Этот метод позволяет получить последовательность сеточных функций $w^{(k)} \in H, k=1,2, \ldots$, сходящуюся по норме пространства $H$ к решению разностной схемы, т.е.
\abovedisplayskip=1pt
\belowdisplayskip=2pt
\noindent
$$
\left\|w-w^{(k)}\right\|_{E} \xrightarrow[k \rightarrow+\infty]{} 0
$$

Метод является одношаговым. Итерация обновления $w^{(k+1)}$ записывается в виде
\abovedisplayskip=1pt
\belowdisplayskip=2pt
\noindent
$$
w_{i j}^{(k+1)}=w_{i j}^{(k)}-\tau_{k+1} r_{i j}^{(k)},
$$

где невязка $r^{(k)}=A w^{(k)}-B$, итерационный параметр
$
\tau_{k+1}=\frac{\left[A r^{(k)}, r^{(k)}\right]}{\left\|A r^{(k)}\right\|_{E}^{2}}
$

В качестве условия остановки используем неравенство
$
\left\|w^{(k+1)}-w^{(k)}\right\|_{E}<\varepsilon
$, где $\varepsilon$ - положительное число, определяющее точность итерационного метода.  Константу $\varepsilon$ для данной задачи предлагается взять равной $10^{-6}$.

\subsection{Вид функций}
В таблице \ref{tb:variant} приведены конкретные функции для данного варианта. Они задаются следующим образом
\abovedisplayskip=1pt
\belowdisplayskip=2pt
\noindent
\begin{gather}
 u_{2}(x, y)=\sqrt{4+x y}, \Pi=[0,4] \times[0,3] \label{eq:u_func}\\
 k_{3}(x, y)=4+x+y \label{eq:k_func}\\
 q_{2}(x, y)=\begin{cases}
              x+y, & x+y \geqslant 0\\
              0, &x+y < 0
             \end{cases} \label{eq:q_func}
\end{gather}

\section{Нахождение \texorpdfstring{$F(x, y),\psi(x, y)$}{F(x,y), psi(x,y)}}
Поскольку для численной реализации нам предлагается сравнить приближеннное решение с истинным, то необходимо найти аналитический вид функции $F(x, y)$ и краевых условий\footnote{В случае варианта 8 необходимо найти вид только функции $\psi(x, y)$} для известного решения $u(x,y) = u_2(x, y) = \sqrt{4 + xy}, \;\Pi = [0,4]\times[0, 3]$, $k(x, y) = k_3(x, y) = 4 + x + y$ и потенциалом $q(x, y) = q_2(x, y) = \max(0, x + y)$. Для определённости, возьмём вектор нормали $\vec{n}$, направленным извне.
\abovedisplayskip=1pt
\belowdisplayskip=2pt
\noindent
\begin{gather*}
 \frac{\partial u}{\partial x} = \frac{y}{2\sqrt{4 + xy}}; \quad \frac{\partial u}{\partial y} = \frac{x}{2\sqrt{4 + xy}}; \\
 \frac{\partial}{\partial x}\left(k(x, y)\frac{y}{2\sqrt{4 + xy}}\right) = \frac{y}{2\sqrt{4 + xy}} - k(x, y)\frac{y^2}{4(4 + xy)^{3/2}}\\
 \text{Аналогично для }\frac{\partial}{\partial y}.
\end{gather*}
Тогда
\abovedisplayskip=1pt
\belowdisplayskip=2pt
\noindent
\begin{gather}
 F(x, y) = -\Delta u+q(x, y) u = \nonumber \\
 = -\frac{\partial}{\partial x}\left(k(x, y)\frac{y}{2\sqrt{4 + xy}}\right) - \frac{\partial}{\partial y}\left(k(x, y)\frac{x}{2\sqrt{4 + xy}}\right) + q(x, y)u = \nonumber \\
 = -\frac{y}{2u(x, y)} + k(x, y)\frac{y^2}{2u^3(x, y)} - \frac{x}{2u(x, y)} + k(x, y)\frac{x^2}{4u^3(x, y)}  + q(x, y)u = \nonumber \\
 = \frac{-2u^2 y + ky^2 - 2u^2x + kx^2 + 4qu^4}{4u^3} = \nonumber \\
 = \frac{-2(4 + xy)(x+y) + (4 + x + y)y^2 - 2(4 + xy)x + (4 + x + y)x^2 + 4qu^4}{4(4 + xy)^{3/2}} = \nonumber \\
 = \frac{x^3 - x^2(2y - 4 - y) -x(8 + 2y^2 - y^2) + y(-8 + 4y + y^2) + 4q(4 + xy)^2}{4(4 + xy)^{3/2}} = \nonumber \\
 = \frac{x^3 - x^2(y - 4) - x(y^2 + 8) + y(y^2 + 4y -8) + 4\max(0, x+y)(4 + xy)^2}{4(4 + xy)^{3/2}} \label{eq:F}
\end{gather}
Приведём пример вычислений функции $\psi(x, y)$ для в <<общем виде>> (знак $\pm$ не значит обязательное наличие члена, в зависимости от направления, одна из компонент нормали может равняться 0).
\begin{gather*}
 \psi(x, y) = \left(k\frac{\partial u}{\partial \vec{n}}\right)(x, y) + \alpha u(x, y) = k\left(\pm \frac{y}{2u} \pm \frac{x}{2u}\right) + \alpha u = \\
 = \frac{(4+x+y)(\pm x \pm y) + 2\alpha(4+xy)}{2\sqrt{4 + xy}}
\end{gather*}
Для $\gamma_R, \gamma_L$ $\alpha=1$, для $\gamma_T, \gamma_B$ $\alpha=0$. Также учтём знаки нормали к поверхности в соответствующих направлениях.
Таким образом, в обозначениях уравнений \ref{eq:a1b1} - \ref{eq:a2b2}
\begin{gather}
 \psi^{(R)}(x, y) = \frac{y(4+x+y) + 2(4+xy)}{2\sqrt{4 + xy}}; \; \psi^{(L)}(x, y) = \frac{-y(4+x+y) + 2(4+xy)}{2\sqrt{4 + xy}}  \label{eq:psi_RL} \\
 \psi^{(T)}(x, y) = \frac{x(4+x+y)}{2\sqrt{4 + xy}};\;
\psi^{(B)}(x, y) = \frac{-x(4+x+y)}{2\sqrt{4 + xy}}\label{eq:psi_TB}
\end{gather}

\section{Описание программной реализации}
\subsection{Формализация требований на домены}
Перед непосредственной реализацией важно понять, как осуществлять разбиение на блоки-домены $\Pi_{ij}$, соблюдая следующие условия:
\begin{enumerate}
 \item отношение количества узлов по переменым $x$ и $y$ в каждом домене принадлежало диапазону $[1 / 2,2]$

 \item количество узлов по переменым $x$ и $y$ любых двух доменов отличалось не более, чем на единицу.
\end{enumerate}

Условия в данной формулировке приведены в постановке задания. Уточним более корректно смысл каждого пункта\footnote{Корректность гарантирована объяснениями преподавателей на лекции, посвящённой постановке задачи}.
Обозначим количество узлов сетки в одном домене $n_x(i)$ и $n_y(j)$ соответственно по $x$ и $y$. Количество узлов, вообще говоря, зависит от числа процессоров $p$, выделенных на задачу, в приведённых обозначениях считаем, что размер зависит от числа процессов, выделенных линейно на каждую ось (далее будет объяснён алгоритм разбиения).

Первое условие утверждает, что для любого домена  его форма должна быть похожа на прямоугольную или квадратную. Формальнее,
\begin{gather}
  \frac{n_x(i)}{n_y(j)} \in [0.5, 2] \quad \forall \Pi_{ij} 
 \label{eq:cond1}
\end{gather}
Данная конфигурация позволяет минимизировать потери во времени на перессылки.

Второе условие даёт равномерность разбиения на домены. Т.е., вообще говоря, размеры доменов по оси $x$ не должны отличаться более, чем на 1, и по $y$ аналогично. Таким образом, $n_x(i), n_y(j)$, фактически должны быть константными, но из-за того, что размеры сетки могут быть не кратны числу процессоров, на граничных блоках мы получаем иные размеры. Именно на то, чтобы отличия в размерах были в этом случае минимальны и направлено ограничение 2. 

Формальнее, 
\begin{gather}
|n_x(i_1) - n_x(i_2)| \leqslant 1, \; |n_y(j_1) - n_y(j_2)| \leqslant 1, \; \forall (i_1, j_1), (i_2, j_2)
\label{eq:cond2}
\end{gather}
\subsection{Алгоритм разбиения на блоки}\label{sec:split}
Приведём алгоритм, удовлетворяющий условиям \ref{eq:cond1},\ref{eq:cond2}.
Обозначим за $p_x$ число процессоров, работающих в ячейках по оси $x$, и $p_y$ -- по $y$. 

Для гарантированного выполнения условия \ref{eq:cond2} возьмём последовательность размеров блоков по каждой оси, отличающихся только на 1 точку. Т.е. будем чередовать по оси $x$ домены с размером $a_x$ и $a_x+1$ (по $y$ соответственно обозначим за $a_y$ и $a_y+1$).

Таким образом, получаем следующие разложения
\begin{gather}
 \sum\limits_{i=1}^{p_x} n_x(i) = k_1 a_x + k_2 (a_x + 1) = M, \; k_1 + k_2 = p_x \Rightarrow a_x p_x + k_2 = M \label{eq:a_x}\\
  \sum\limits_{j=1}^{p_y} n_y(j) = s_1 a_y + s_2 (a_y + 1) = N, \; s_1 + s_2 = p_y \Rightarrow a_y p_y + s_2 = N \label{eq:a_y}
\end{gather}
Условие \ref{eq:cond1} в новых обозначениях формулируется как
$
 0.5 \leqslant \frac{a_x}{a_y} \leqslant 2
$, т.к. в приведённой формулировке алгоритма чередоваться б\'{о}льшие блоки будут одновременно по осям.

Из формул \ref{eq:a_x}, \ref{eq:a_y} видно, что необходимо поделить с остатком $M$  и $N$ на количество процессоров по осям. При этом не стоит забывать, что должно соблюдаться неравенство $p_x p_y \leqslant p$.

Предлагается следующая схема: берём $p_x = 2^k$ процессоров на ось $x$ и $p_y = \lfloor\frac{p}{2^k}\rfloor$ процессоров на ось $y$.\footnote{Данная формула носит общий характер, в рамках текущего задания $p=2^n$ и можно сразу сказать, что $p_y = 2^{n-k}$} Для выполнения условия \ref{eq:cond1} логичным кажется выбирать эти числа, исходя из пропорции \ref{eq:k_frac}.
\begin{gather}
 \frac{2^k}{\frac{p}{2^k}} = \frac{M}{N} \Rightarrow \frac{2^{2k}}{p} = \frac{M}{N} \Rightarrow 2^{2k} = \frac{pM}{N} \Rightarrow k = \Bigl\lfloor \frac{\log_2\left(\frac{pM}{N}\right)}{2}\Bigr\rfloor \label{eq:k_frac}
\end{gather}
В случае $p=2^n$ выражение \ref{eq:k_frac} переходит в $k = \Bigl\lfloor \frac{n + \log_2\left(\frac{M}{N}\right)}{2}\Bigr\rfloor $.

Таким образом, итоговая схема получения блоков, удовлетворяющих условиям \ref{eq:cond1} (из-за выбора $k$ согласно \ref{eq:k_frac}) и \ref{eq:cond2} (из-за выбора определённой последовательности), выглядит следующим образом:
\begin{enumerate}
 \item Задаём $p_x = 2^{\Bigl\lfloor \frac{\log_2\left(\frac{pM}{N}\right)}{2}\Bigr\rfloor}$, $p_y = \Bigl\lfloor\frac{p}{p_x}\Bigr\rfloor$.
 \item Получаем $a_x = \lfloor \frac{M}{p_x}\rfloor$, $a_y = \lfloor \frac{N}{p_y}\rfloor$ и фиксируем $k_2 = M \mod p_x$, $s_2 = N \mod p_y$
 \item Далее генерируем $k_1 = p_x - k_2$ доменов по оси $x$ с размером $a_x$ и $s_1 = p_y - s_2$ доменов по оси $y$ с размером $a_y$.
 \item Затем начинается генерация $k_2$ доменов по оси $x$ с размером $a_x + 1$ и $s_2$ доменов по оси $y$ с размером $a_y + 1$
\end{enumerate}
\subsection{Реализация с использованием MPI и OpenMP}
В рамках экспериментов была осуществлена реализация описанной разностной схемы с использованием MPI и OpenMP. Реализация написана на языке С. Классическая MPI реализация приведена в \ref{code:list1}, с методом сопряжённых градиентов в \ref{sec:code_cg}. 

Также (из-за неэффективности вычисления на системе Blue Gene/P) реализована схема оптимизации с помощью сопряжённых градиентов (реализация с MPI в приложении \ref{code:list3}). Метод сопряжённых градиентов (везде далее CG) может показывать нестабильность в случае нессиметричной матрицы СЛАУ, результаты сравнения продемонстрированы в сводных таблицах. Также для сравнения приводится время вычисления решения на ноутбуке c 4 ядрами (8-ю логическими процессорами)\footnote{Asus ZenBook BX433F, Processor	Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz   1.99 GHz. Installed RAM	16.0 GB (15.8 GB usable). System type	64-bit operating system, x64-based processor.}

Реализация с использованием OpenMP отличается добавлением в циклах директив pragma omp parallel for.

Коротко опишем ключевые этапы программы с MPI. С помощью MPI\_Ca\-rt\_cre\-ate создаётся топология на прямоугольной сетке, совпадающей по реализации с разбиением, предлагаемом в разделе \ref{sec:split}.  

Далее проверяется, какая ошибка каждого блока по разностной схеме от истинного решения, известного заранее. После проверки начинается основной цикл оптимизации. Критериев останова является получение нормы относительной ошибки меньше заданного значения. В случае сопряжённых градиентов - получение отношения нормы остатков к норме матрицы правой части меньше заданного числа.

В цикле заполняются блоки, расширенные по одной точке по каждому направлению (для получения от соседних процессов информации об их граничных точках). Обмен происходит с помощью асинхронной отправки и синхронного получения.

Стоит отметить, что на локальном запуске не требовалось наличия функции MPI\_Wait(), однако Blue Gene/P потребовал написания данной реализации из-за специфики архитектуры. 

После этого вычисляется остаток на текущем шаге и перед получением произведения $Ar$ также проводится необходимая синхронизация. 

Затем вычисляется коэффициент (коэффициенты, в случае сопряжённых градиентов) для оптимизации и делается шаг.

В конце программы происходит барьерная синхронизация и вывод результатов по времени на стандартный поток вывода и по данным в необходимые для визуализации файлы.
\subsection{Реализация с использованием CUDA}
В дополнение к приведённой выше реализации на MPI+OpenMP был реализован код на CUDA (см. приложение \ref{code:list4}). Для этого каждая функция, вычисляющая значение в точке, и циклы над массивами по индексам были сделаны $\_\_device\_\_$ кодом. 

Функции умножения на матрицу $A$ и получение матрицы $B$ перенесены на память $device$ также. 

Основной цикл вычислений теперь максимально упростился -- осуществляется уже стандартный вызов инициализации MPI, создание топологии процессоров. Затем происходит инициализация cuda-профилировщика и начинается самое важное -- необходимо распределить для каждого MPI-процессора его решётки и блоки внутри неё. Для этого задаётся в виде констант число нитей на один блок по каждой из двумерных осей.

В результате, получается разбиение, в котором общее число нитей равно числу точек в гриде этого процессора.

В основном цикле оптимизации происходит рассчёт, аналогичный предыдущему пункту. Однако важно отметить ключевые изменения: 
\begin{enumerate}
 \item Фукнция пересылки границ теперь использует динамическую память устройства, поэтому внутри есть вызовы копирований памяти по необходимости на хост.
 \item Подсчёт скалярного произведения взят из общего доступа и синхронизирует все нити для получения единого значения. Как показалось, это самая сложная часть в реализации при переходе к cuda.
\end{enumerate}

По завершению используемые ресурсы освобождаются и выводится затраченное время.

\subsubsection{Сборка cuda-программы}
При реализации сначала сделаны собственные библиотеки для удобства поиска ошибок, однако после компиляции на Polus вылетало сообщение о провале запуска MPI\_Init.

Поэтому был сделан общий файл и слинкован с MPI библиотекой (см. makefile в \ref{sec:makefile}. Однако результат оказался аналогичным.
\subsubsection{Запуск скомпилированной программы}
Для запуска был сделан файл постановки на задачу (см. \ref{sec:task}). Он добавлял параметры запуска: число процессоров по стойкам, число стоек, число gpu на стойках и количество нитей для OpenMP.

В приложении указано число процессоров 4 и минимальные требования задания.

Запуск приводит к ошибке в MPI\_Init, которую не смог исправить (недублирующаяся часть приведена ниже):
\begin{lstlisting}
Rank 0 of MPI_COMM_WORLD could not getenv OPAL_PREFIX. Goodbye.
--------------------------------------------------------------------------
Primary job  terminated normally, but 1 process returned
a non-zero exit code. Per user-direction, the job has been aborted.
--------------------------------------------------------------------------
--------------------------------------------------------------------------
Sorry!  You were supposed to get help about:
    opal_init:startup:internal-failure
But I couldn't open the help file:
    /__unresolved_path______________________________/exports/optimized/share/spectrum_mpi/help-opal-runtime.txt: No such file or directory.  Sorry!
--------------------------------------------------------------------------
........
*** An error occurred in MPI_Init
*** on a NULL communicator
*** MPI_ERRORS_ARE_FATAL (processes in this communicator will now abort,
***    and potentially your MPI job)
[polus-c4-ib.bmc.hpc.cs.msu.ru:6428] Local abort before MPI_INIT completed completed successfully, but am not able to aggregate error messages, and not able to guarantee that all other processes were killed!
--------------------------------------------------------------------------
\end{lstlisting}
\section{Результаты на системах Blue Gene/P и Polus}
Для данной задачи выполнены подсчёты ускорения программы на системах Blue Gene/P и Polus.

Под ускорением программы, запущенной на $p$ МРІ-процессах, понимается величина:
\abovedisplayskip=-1pt
\belowdisplayskip=-1pt
\noindent
\begin{gather*}
S_{p}=\frac{T_{m}}{T_{p}}
\end{gather*}
где $T_{m}-$ время работы на минимальном числе МРІ-процессов, $T_{p}-$ время работы программы на $p$ МРІ-процессах.  

Результаты запусков стандартной реализации на системе Blue Gene/P с использованием MPI и OpenMP приведены в \ref{tb:BG_MPI} и \ref{tb:BG_MPI_MP}. 

Результаты использования только MPI \ref{tb:BG_MPI} показывают лишь замедление времени исполнения при увеличении числа узлов. Возможные варианты объяснения видятся следующие: 
\begin{itemize}                                                                                                                                                                                \item Топология, создаваемая MPI\_Cart, становится ресурсоёмкой при нескольких обменах в ходе исполнения программы
\item Медленный метод сходимости                                                                                                                                                                        \item Загрузка суперкомпьютера                                                                                                                                                                            \item Компиляция без оптимизации под архитектуру
                                                                                                                                                                    \end{itemize}
Также видна закономерность в том, что на б\'{о}льшей сетке метод оптимизации сходится быстрее\footnote{Отметим, что чтобы уместиться в разрешённые временные рамки, была изменена начальная инициализация.}.                                                                                                                                                                    
\begin{table}[ht!]
\begin{tabularx}{\textwidth}{|r|L|L|L|}
\hline Число процессоров $p$ & Cетка $M \times N$ & Время $T$ (мин) & Ускорение $S$ \\
\hline 128 & $500 \times 1000$ & 5.031 & 1\\
256 & $500 \times 1000$ & 6.023 & 0.83\\
512 & $500 \times 1000$ & 9.889 & 0.51\\
\hline
\textbf{128} & $\mathbf{1000 \times 1000}$ & \textbf{1.975} & \textbf{1}\\
256 & $1000 \times 1000$ & 2.341& 0.84\\
512 & $1000 \times 1000$ & 3.488 & 0.57\\
 \hline
 \textbf{(локально, CG) 4} & $\mathbf{500 \times 1000}$ & \textbf{4.491} & \textbf{1.12}\\
 \hline
  (локально, CG) 4 & $1000 \times 1000$ & 20.674 & 0.10\\
 \hline
\end{tabularx}
\caption{Результаты расчетов MPI версии на ПВС IBM Blue Gene/P}
\label{tb:BG_MPI}
\end{table}

Рассмотрим результаты для запусков программы, скомпилированной с OpenMP директивами.
\begin{table}[ht!]
\begin{tabularx}{\textwidth}{|r|L|L|L|}
\hline Число процессоров $p$ & Cетка $M \times N$ & Время $T$ (мин) & Ускорение $S$ \\
\hline 128 & $500 \times 1000$ & 5.391& 1\\
256 & $500 \times 1000$ & 3.214& 1.68\\
\textbf{512} & $\mathbf{500 \times 1000}$ & \textbf{3.213}& \textbf{1.68}\\
\hline
128 & $1000 \times 1000$ & 9.424& 1\\
256 & $1000 \times 1000$ & 5.573& 1.69\\
\textbf{512} & $\mathbf{1000 \times 1000}$ &\textbf{3.554} & \textbf{2.65}\\
 \hline
 (локально, CG) 4 & $500 \times 1000$ &  8.905 & 0.61\\
 \hline
  (локально, CG) 4 & $1000 \times 1000$ & 11.094 & 0.85\\
 \hline
\end{tabularx}
\caption{Результаты расчетов MPI+OpenMP версии на ПВС IBM Blue Gene/P}
\label{tb:BG_MPI_MP}
\end{table}

Для сравнения также приводится время, потраченное на локальном компьютере с 4 ядрами на тех же размерах сеток. Для корректности сравнения приведём результаты запуска метода сопряжённых градиентов на системе Blue Gene/P (см. \ref{tb:CG_BG_MPI}, \ref{tb:CG_BG_MPI_MP})
\begin{table}[ht!]
\begin{tabularx}{\textwidth}{|r|L|L|L|}
\hline Число процессоров $p$ & Cетка $M \times N$ & Время $T$ (мин) & Ускорение $S$ \\
\hline 128 & $500 \times 1000$ & 0.824 & 1\\
256 & $500 \times 1000$ &  0.470& 1.75\\
\textbf{512} & $\mathbf{500 \times 1000}$ & \textbf{0.470} & \textbf{1.75}\\
\hline
128 & $1000 \times 1000$ & 1.856& 1\\
256 & $1000 \times 1000$ & 1.053& 1.76\\
\textbf{512} & $\mathbf{1000 \times 1000}$ & \textbf{0.608} &\textbf{3.05}\\
 \hline
 (локально, CG) 4 & $500 \times 1000$ & 4.491 & 0.183\\
 \hline
  (локально, CG) 4 & $1000 \times 1000$ & 20.674 & 0.090\\
 \hline
\end{tabularx}
\caption{Результаты расчетов MPI версии \textbf{с CG} на ПВС IBM Blue Gene/P}
\label{tb:CG_BG_MPI}
\end{table}
\begin{table}[ht!]

\begin{tabularx}{\textwidth}{|r|L|L|L|}
\hline Число процессоров $p$ & Cетка $M \times N$ & Время $T$ (мин) & Ускорение $S$ \\
\hline 128 & $500 \times 1000$ & 5.742& 1\\
256 & $500 \times 1000$ & 4.081& 1.41\\
\textbf{512} & $\mathbf{500 \times 1000}$ & \textbf{3.089}& \textbf{1.86}\\
\hline
128 & $1000 \times 1000$ & 0.422& 1\\
\textbf{256} & $\mathbf{1000 \times 1000}$ & \textbf{0.310}& \textbf{1.36}\\
512 & $1000 \times 1000$ &3.495 & 0.121\\
 \hline
 (локально, CG) 4 & $500 \times 1000$ & 8.905 & 0.64\\
 \hline
  (локально, CG) 4 & $1000 \times 1000$ & 11.094 & 0.04\\
 \hline
\end{tabularx}
\caption{Результаты расчетов MPI+OpenMP версии \textbf{с CG} на ПВС IBM Blue Gene/P}
\label{tb:CG_BG_MPI_MP}
\end{table}

На системе ПВС IBM Polus с заданной точностью $1e-6$ за 15 минут не удалось получить результаты по некоторым конфигурациям, поэтому проведено сравнение только метода с CG оптимизацией.

\begin{table}[ht!]
\begin{tabularx}{\textwidth}{|r|L|L|L|}
\hline Число процессоров $p$ & Сетка $M \times N$ & Время $T$ (мин) & Ускорение $S$ \\
\hline 4 & $500 \times 500$ & 1.391& 1\\
8 & $500 \times 500$ & 0.669& 2.08\\
16 & $500 \times 500$ & 0.363& 3.83\\
\textbf{32} & $\mathbf{500 \times 500}$ & \textbf{0.257}& \textbf{5.41}\\
\hline
4 & $500 \times 1000$ & 4.569 & 1\\
8 & $500 \times 1000$ & 2.647 & 1.73\\
16 & $500 \times 1000$ & 1.465 & 3.12\\
\textbf{32} & $\mathbf{500 \times 1000}$ & \textbf{0.791}& \textbf{5.78}\\ \hline
(локально, CG) 4 & $500 \times 500$ &  2.616& 0.53\\
 \hline
  \textit{(локально, CG) 4} & $\mathit{500 \times 1000}$ & \textit{4.491} & \textit{1.02}\\
 \hline
\end{tabularx}
\caption{Таблица с результатами расчетов MPI версии (только CG) на ПВС IBM Polus}
\label{tb:P_MPI}
\end{table}
На основании таблиц \ref{tb:BG_MPI} - \ref{tb:P_MPI} можно сделать следующие выводы.

\textbf{На Blue Gene/P}
\begin{itemize}
    \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
 \item OpenMP версия показывает ускорение почти в два раза. Без указания директив $pragma$ у параллельных циклов (результаты таблицы \ref{tb:BG_MPI}) нет должного ресурса параллелизма и при увеличении числа процессоров наблюдается увеличение времени.
 \item Реализация метода оптимизации сопряжённых направлений ускоряет вычисление в 5 раз (из сравнения \ref{tb:BG_MPI} с \ref{tb:CG_BG_MPI})
 \item При добавлении директив OpenMP наблюдается увеличение времени работы. Особенно выделяется случай с 512 процессорами и сеткой размера $1000\times 1000$. В случае прямоугольной сетки увеличение времени объясняется наружением симметричности матрицы СЛАУ, что не позволяет воспользоваться преимуществами метода сопряжённых градиентов.
 
 В случае с 512 процессорами увеличение времени работы можно объяснить тем, что размеры блоков (исходя из вывода \ref{eq:k_frac} и дальнейшего алгоритма) различаются почти в 2 раза (1000/32 и 1000/16), что является граничным случаем  условий на домены и также нарушает симметрию.
\end{itemize}

\textbf{На Polus}
\begin{itemize}
    \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
 \item Метод конечных разностей сходится явно дольше, чем на Blue Gene/P (наблюдалось достижение точности 6e-5 только к 15 минуте подсчёта).
 \item Идеально демонстрируется ускорение за счёт взятия б\'{о}льшего числа процессоров (получение ускорения в 5-6 раз при взятии 32 процессоров).
 \item Вычислительная мощность на прямоугольной сетке совпадает (или даже уступает производительности ноутбука с приведённым выше описанием).
\end{itemize}
\begin{figure}[ht!]
        \centering
        \includegraphics[width=\textwidth]{u_local_4_500_1000.png} 
        \caption{Результат на сетке $500 \times 1000$}\label{fig:500_1000}
\end{figure}
Итоговые результаты функций для сеток с наибольшим числом узлов приведены на рисунках \ref{fig:500_1000}, \ref{fig:1000_1000}.
\begin{figure}[ht!]
        \centering
        \includegraphics[width=\textwidth]{u_local_4_1000_1000.png} 
        \caption{Результат на сетке $1000 \times 1000$}
        \label{fig:1000_1000}
\end{figure}

\section{Заключение}
В ходе проведённых экспериментов была реализована программа для численного решшения СЛАУ методом конечных разностей. Вычислительный эксперимент, с целью получения информативных результатов, дополнен сравнением с результатами, полученными методом сопряжённых градиентов и запуском на локальном компьютере.

Также описан аналитически метод, лежащий в основе разбиения на блоки MPI\_Cart\_create, получены аналитические выражения для правых частей и описана разностная схема.

Для представления результатов также использовались стандартные методы визуализации python, получающие на вход файлы, записанные каждым доменом (процессором) отдельно.

Осуществлена реализация CUDA, работающая на локальном компьютере, однако для данной реализации не было смысла приводить результаты локальной системы, а на суперкомпьютере с системой Polus не удалось получить работающего запуска.
\newpage
\section{Литература}
\begin{thebibliography}{}
\bibitem{Bahvalov97} Бахвалов Н.С., Жидков Н.П., Кобельков Г.М. ЧИСЛЕННЫЕ МЕТОДЫ. - М.: Наука, 1987.
 
\end{thebibliography}
\newpage
\section{Приложение 1. Код MPI программы}\label{sec:code}
\lstinputlisting[language=C, style=customc, label={code:list1}]{../code/neyman_pde_mpi.c}{}
\section{Приложение 2. Код MPI программы с оптимизацией сопряжёнными градиентами}\label{sec:code_cg}
\lstinputlisting[language=C, style=customc, label={code:list3}]{../code/neyman_pde_mpi_cg.c}{}
\section{Приложение 3. Код MPI+CUDA программы}\label{sec:code_cuda}
\lstinputlisting[language=C, style=customc, label={code:list4}]{../code/main_huge.cu}{}
\section{Приложение 4. Сборка CUDA программы}\label{sec:makefile}
\lstinputlisting[label={code:list5}]{../code/makefile}{}
\section{Приложение 5. Запуск CUDA}\label{sec:task}
\lstinputlisting[label={code:list6}]{../code/task.lsf}{}

\end{document}
